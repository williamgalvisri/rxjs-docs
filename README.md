# Â¿CÃ³mo usar RxJS y no morir en el intento? ğŸ˜± ğŸ’¯
![CÃ³mo sobrevivir a RxJS](https://media.giphy.com/media/YFkpsHWCsNUUo/giphy.gif)
## 1. IntroducciÃ³n a RxJS :rocket:
ğŸ’¬ **Â¿QuÃ© es RxJS?**
- RxJS (Reactive Extensions for JavaScript) es una librerÃ­a para manejar flujos de datos asÃ­ncronos y eventos mediante programaciÃ³n reactiva.
  
ğŸ’¬ **Conceptos clave:**
- **Observables:** Objetos que emiten datos a lo largo del tiempo.
- **Observers:** Subscriptores que reaccionan a los datos emitidos.
- **Operators:** Funciones que permiten transformar, filtrar, combinar o manipular flujos de datos.
- **Asynchronous:** Las operaciones pueden ejecutarse de manera independiente y no necesitan esperar a que otras terminen.


## 2. ExplicaciÃ³n del flujo ğŸ‘‹
1. **CreaciÃ³n:** Un Observable emite datos.
2. **SuscripciÃ³n:** Un Observer se suscribe para recibir esos datos.
3. **TransformaciÃ³n:** Uso de operadores para transformar los datos.
4. **CancelaciÃ³n:** DesuscripciÃ³n para liberar recursos.

**Diagrama:**
[CreaciÃ³n] â†’ [SuscripciÃ³n] â†’ [TransformaciÃ³n] â†’ [CancelaciÃ³n]

**Ejemplo | [Stackblitz](https://stackblitz.com/edit/stackblitz-starters-xzz2xd):**
```ts 
ngOnInit() {
    // [CreaciÃ³n]
    const _observable$ = new Observable<string>((observer) => {
      observer.next('Primer valor');
    });
    
    // [SubscripciÃ³n]
    const subscription = _observable$
      // [TransformaciÃ³n]
      .pipe(debounceTime(1000))
      .subscribe((value) => {
        this.value = value;
      });
    // [CancelaciÃ³n]
    setTimeout(() => {
      subscription.unsubscribe();
    }, 2000);
}
```
## 3. Operadores | [Stackblitz](https://stackblitz.com/edit/stackblitz-starters-d4bxsh?file=src%2Fmain.ts)
- AcontinuaciÃ³n crearemos un operador para ejemplificar el uso: 
```ts 

[multiply-values.ts]
export function multiplyValue(
  number: number
): OperatorFunction<number, number> {
  return (source: Observable<number>): Observable<number> =>
    new Observable((observer) => {
      return source.pipe(map((value) => value * number)).subscribe(observer);
    });
}
...

[main.ts]
ngOnInit() {
  const _observable$ = of(1, 2, 3);
  const subscription = _observable$
    .pipe(
      multiplyValue(5),
      tap((value) => {
        this.values.push(value);
      })
    )
    .subscribe();

  setTimeout(() => {
    subscription.unsubscribe();
  }, 2000);
}
```
**Resultado:**
```
5
10
15
```
**Operadores mÃ¡s usados:**
- **map**: Transforma los valores emitidos por un observable. Aplica una funciÃ³n a cada valor emitido por un observable y emite los valores resultantes.
```ts
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

of(1, 2, 3).pipe(
  map(value => value * 2)
).subscribe(console.log); // Output: 2, 4, 6
```
- **filter**:  Filtra los valores emitidos. Emite solo los valores que pasan una condiciÃ³n determinada.

```ts
import { of } from 'rxjs';
import { filter } from 'rxjs/operators';

of(1, 2, 3, 4, 5).pipe(
  filter(value => value % 2 === 0)
).subscribe(console.log); // Output: 2, 4
```
- **mergeMap**: Combina observables de manera plana. Mapea cada valor a un observable y fusiona los resultados.

```ts
import { of } from 'rxjs';
import { filter } from 'rxjs/operators';

of(1, 2, 3, 4, 5).pipe(
  filter(value => value % 2 === 0)
).subscribe(console.log); // Output: 2, 4
```

- **switchMap**: Cambia a un nuevo observable, cancelando el anterior. Mapea cada valor a un observable, pero solo emite los valores del observable mÃ¡s reciente.
  
```ts
import { of } from 'rxjs';
import { switchMap } from 'rxjs/operators';

of(1, 2, 3).pipe(
  switchMap(id => of(`Item ${id}`))
).subscribe(console.log); // Output: Item 3
```

- **concatMap**: Procesa los valores uno tras otro en orden. Mapea cada valor a un observable y concatena los resultados en orden.
  
```ts
import { of } from 'rxjs';
import { concatMap, delay } from 'rxjs/operators';

of(1, 2, 3).pipe(
  concatMap(value => of(`Item ${value}`).pipe(delay(1000)))
).subscribe(console.log); // Output: Item 1, Item 2, Item 3 (one per second)
```

- **debounceTime**: Espera un tiempo antes de emitir el valor mÃ¡s reciente. Retrasa la emisiÃ³n de valores por un perÃ­odo de tiempo, emitiendo solo el valor mÃ¡s reciente despuÃ©s de la pausa.

```ts
import { fromEvent } from 'rxjs';
import { debounceTime, map } from 'rxjs/operators';

const input = document.getElementById('input');
fromEvent(input, 'input').pipe(
  debounceTime(300),
  map(event => (event.target as HTMLInputElement).value)
).subscribe(console.log);
```

- **distinctUntilChanged**: Evita emitir valores repetidos. Solo emite valores cuando son diferentes al valor anterior.

```ts
import { of } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';

of(1, 1, 2, 3, 3, 4).pipe(
  distinctUntilChanged()
).subscribe(console.log); // Output: 1, 2, 3, 4
```

- **catchError**: Maneja errores en la cadena de operadores. Permite manejar errores que ocurren en el flujo del observable y emitir un nuevo observable o valor alternativo.

```ts
import { of, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

throwError('Error!').pipe(
  catchError(err => {
    console.error(err);
    return of('Recovered from error');
  })
).subscribe(console.log); // Output: Error! Recovered from error
```

- **take**: Emite un nÃºmero especÃ­fico de valores. Completa el observable despuÃ©s de emitir un nÃºmero determinado de valores.

```ts
import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

interval(1000).pipe(
  take(3)
).subscribe(console.log); // Output: 0, 1, 2
```

- **combineLatest**: Combina los valores mÃ¡s recientes de mÃºltiples observables. Emite valores cuando cada uno de los observables emitiÃ³ al menos un valor, combinando los Ãºltimos valores de cada uno.

```ts
import { combineLatest, of } from 'rxjs';

const observable1$ = of(1, 2, 3);
const observable2$ = of('a', 'b', 'c');

combineLatest([observable1$, observable2$]).subscribe(([value1, value2]) => {
  console.log(value1, value2);
});
// Output: 3 c (solo el Ãºltimo valor de cada observable)
```

- **forkJoin**: Espera a que todos los observables se completen y emite los Ãºltimos valores. Combina mÃºltiples observables y emite un solo valor que contiene los Ãºltimos valores emitidos por cada uno de los observables cuando todos han completado.

```ts
import { of, forkJoin } from 'rxjs';
import { delay } from 'rxjs/operators';

const observable1$ = of('Hello').pipe(delay(1000));
const observable2$ = of('World').pipe(delay(2000));

forkJoin([observable1$, observable2$]).subscribe(([value1, value2]) => {
  console.log(value1, value2); // Output: Hello World
});
```

- **lastValueFrom**: Convierte un observable en una promesa y obtiene el Ãºltimo valor emitido. Convierte un observable en una promesa que resuelve con el Ãºltimo valor emitido por el observable. Si el observable no emite ningÃºn valor, la promesa se rechaza.

```ts
import { of, lastValueFrom } from 'rxjs';
import { delay } from 'rxjs/operators';

const observable$ = of('Hello', 'World').pipe(delay(1000));

lastValueFrom(observable$).then(value => {
  console.log(value); // Output: World
}).catch(err => {
  console.error('Error:', err);
});
```

## 4. Ahora hablemos de lo que no se puede hacer, antipatrones que son...
![Antipatron](https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExdzE5eWE1YmIxOXFnYzJmOG9rdGJucWRwNDN2cXl0ZWs3eXJsNjB2aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/X9QEx7PMwNELs7l4p0/giphy.gif)
Los antipatrones son prÃ¡cticas comunes en el desarrollo de software que, aunque pueden parecer Ãºtiles o eficientes en el corto plazo, generalmente conducen a problemas de mantenimiento, rendimiento o escalabilidad en el largo plazo. En el contexto de RxJS, es importante conocer estos antipatrones para evitarlos y asÃ­ escribir cÃ³digo mÃ¡s robusto y sostenible.

1. **Suscripciones Anidadas | [Stackblitz](https://stackblitz.com/edit/stackblitz-starters-yj8cok?file=src%2Fmain.ts) | [Stackblitz 1](https://stackblitz.com/edit/stackblitz-starters-6undij?file=src%2Fmain.ts):**
Ocurre cuando se suscribe a un observable dentro de otro observable, en lugar de utilizar operadores de combinaciÃ³n como mergeMap, switchMap, concatMap, etc.

**Problema:**
Las suscripciones anidadas pueden llevar a un cÃ³digo difÃ­cil de seguir, errores de lÃ³gica y fugas de memoria.

```ts
  const observable1$ = of('Hello').pipe(delay(1000));
  const observable2$ = of('World').pipe(delay(2000));

  // AntipatrÃ³n: Suscripciones anidadas
  observable1$.subscribe((value1) => {
    console.log('First observable:', value1);
    observable2$.subscribe((value2) => {
      console.log('Second observable:', value2);
    });
  });
```
**SoluciÃ³n:**
```ts
  const observable1$ = of('Hello').pipe(delay(1000));
  const observable2$ = of('World').pipe(delay(2000));

  // CorrecciÃ³n: Usar switchMap en lugar de suscripciones anidadas
  observable1$
  .pipe(
    switchMap((value1) => {
      console.log('First observable:', value1);
      return observable2$;
    })
  )
  .subscribe((value2) => {
    console.log('Second observable:', value2);
  });
```

2. **No Desuscribirse:**
Ocurre cuando te suscribes a un observable, pero nunca te desuscribes, lo que puede causar fugas de memoria.

**Problema:**
En aplicaciones de larga duraciÃ³n, no desuscribirse de observables que no se completan puede llevar a que se acumulen suscripciones y a un consumo innecesario de memoria.
```ts
const subscription = observable$.subscribe(value => {
  console.log(value);
});
// No se llama a subscription.unsubscribe() en ningÃºn momento
```
**SoluciÃ³n:**
Utiliza el operador takeUntil, unsubscribe manualmente o usa el patrÃ³n async en Angular:

```ts
ngOnDestroy() {
  this.destroy$.complete()
}
...
const subscription = observable$.pipe(
  takeUntil(this.destroy$)
).subscribe(value => {
  console.log(value);
});

// O manualmente
subscription.unsubscribe();
```

3. **Demasiadas Suscripciones en Componentes:**
Ocurre cuando se crean muchas suscripciones individuales en un componente en lugar de usar operadores para combinarlas.


**Problema:**
Esto lleva a un cÃ³digo desorganizado y difÃ­cil de mantener.
```ts
observable1$.subscribe(value1 => console.log(value1));
observable2$.subscribe(value2 => console.log(value2));
observable3$.subscribe(value3 => console.log(value3));
```

**SoluciÃ³n:**
Usa combineLatest, forkJoin u otros operadores de combinaciÃ³n

```ts
combineLatest([observable1$, observable2$, observable3$]).subscribe(([value1, value2, value3]) => {
  console.log(value1, value2, value3);
});
```


4. **Usar RxJS para Todo:**
RxJS es una herramienta poderosa, pero no todo requiere el uso de observables y operadores de RxJS.

**Problema:**
Abusar de RxJS para manejar lÃ³gica simple o sincronizaciones sencillas puede complicar innecesariamente el cÃ³digo.

```ts
// Uso innecesario de RxJS para una operaciÃ³n sincrÃ³nica simple
const observable$ = of(1).pipe(
  map(value => value + 1)
);

observable$.subscribe(console.log);
```
**SoluciÃ³n:**
```ts
const value = 1 + 1;
console.log(value); // Simple operaciÃ³n sincrÃ³nica
```

## En conclusiÃ³n
RxJS ofrece una rica caja de herramientas para manejar la programaciÃ³n asÃ­ncrona y reactiva. Al comprender y aplicar correctamente los operadores disponibles, y al evitar antipatrones comunes, puedes escribir cÃ³digo mÃ¡s limpio, eficiente y mantenible. El dominio de RxJS es esencial para cualquier desarrollador que trabaje con aplicaciones modernas que requieran un manejo avanzado de flujos de datos.

![Hack the planet](
https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExY3FicG9rd2N6aTNuY3pocW1zdGw4bjZleXB3Znd5ajFjMGFkZGtscCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/FnGJfc18tDDHy/giphy.gif)
